<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LabyrinthWorm // Trophy Tracker</title>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0d0d14;
  --surface: #13131f;
  --surface2: #1a1a2e;
  --surface3: #1f1f35;
  --border: #2a2a4a;
  --border2: #3a3a5a;
  --ps-blue: #0070d1;
  --ps-blue-light: #1a8fff;
  --ps-blue-glow: rgba(0,112,209,0.3);
  --plat: #b8c8e8;
  --plat-glow: rgba(184,200,232,0.3);
  --gold: #f0c040;
  --silver: #a0b0c0;
  --bronze: #c07840;
  --green: #00c896;
  --green-glow: rgba(0,200,150,0.2);
  --amber: #f0a020;
  --red: #e04050;
  --red-glow: rgba(224,64,80,0.2);
  --text: #e8e8f8;
  --text2: #b0b0d8;
  --text3: #8080a8;
  --radius: 10px;
  --radius-sm: 6px;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Inter', sans-serif;
  min-height: 100vh;
  background-image: 
    radial-gradient(ellipse at 20% 0%, rgba(0,112,209,0.08) 0%, transparent 60%),
    radial-gradient(ellipse at 80% 100%, rgba(184,200,232,0.05) 0%, transparent 60%);
}

/* HEADER */
header {
  background: rgba(13,13,20,0.95);
  backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border);
  padding: 0 28px;
  position: sticky;
  top: 0;
  z-index: 100;
  display: flex;
  align-items: stretch;
  gap: 0;
  height: 60px;
}

.logo-wrap {
  display: flex;
  align-items: center;
  padding-right: 28px;
  border-right: 1px solid var(--border);
  gap: 12px;
}

.ps-icon {
  width: 32px;
  height: 32px;
  background: var(--ps-blue);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Orbitron', sans-serif;
  font-size: 14px;
  font-weight: 900;
  color: white;
  box-shadow: 0 0 16px var(--ps-blue-glow);
  flex-shrink: 0;
}

.logo {
  font-family: 'Orbitron', sans-serif;
  font-size: 15px;
  font-weight: 700;
  letter-spacing: 2px;
  color: var(--text);
}
.logo span { color: var(--text3); font-weight: 400; }

.header-stats {
  display: flex;
  align-items: center;
  gap: 0;
  padding-left: 28px;
  flex: 1;
}

.hstat {
  display: flex;
  flex-direction: column;
  padding: 0 20px;
  border-right: 1px solid var(--border);
  gap: 2px;
}
.hstat:last-child { border-right: none; }
.hstat-label { font-size: 10px; text-transform: uppercase; letter-spacing: 1.5px; color: var(--text2); font-family: 'Rajdhani', sans-serif; font-weight: 600; }
.hstat-val { font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; color: var(--text); }
.hstat-val.blue { color: var(--ps-blue-light); }
.hstat-val.green { color: var(--green); }
.hstat-val.plat { color: var(--plat); }

/* TABS */
.tabs {
  display: flex;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 0 28px;
  gap: 4px;
}
.tab {
  padding: 12px 20px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  cursor: pointer;
  color: var(--text3);
  border-bottom: 2px solid transparent;
  transition: all .2s;
  display: flex;
  align-items: center;
  gap: 8px;
}
.tab:hover { color: var(--text2); }
.tab.active { color: var(--ps-blue-light); border-bottom-color: var(--ps-blue-light); }
.tab .tab-count {
  background: var(--surface3);
  border-radius: 10px;
  padding: 1px 7px;
  font-size: 10px;
  font-family: 'Orbitron', sans-serif;
}
.tab.active .tab-count { background: var(--ps-blue); color: white; }

/* LAYOUT */
.container { padding: 20px 28px; max-width: 1440px; margin: 0 auto; }

/* CONTROLS */
.controls-bar {
  display: flex;
  gap: 10px;
  margin-bottom: 14px;
  align-items: center;
}

.search-wrap {
  flex: 1;
  position: relative;
}
.search-icon {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text3);
  font-size: 14px;
  pointer-events: none;
}
input[type=text] {
  width: 100%;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  padding: 9px 14px 9px 36px;
  font-family: 'Inter', sans-serif;
  font-size: 13px;
  outline: none;
  transition: border-color .2s, box-shadow .2s;
}
input[type=text]:focus {
  border-color: var(--ps-blue);
  box-shadow: 0 0 0 3px var(--ps-blue-glow);
}
input[type=text]::placeholder { color: var(--text3); }

.ps-select {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  padding: 9px 12px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.5px;
  cursor: pointer;
  outline: none;
  transition: border-color .2s;
}
.ps-select:focus { border-color: var(--ps-blue); }

.suggest-btn {
  background: linear-gradient(135deg, var(--ps-blue), var(--ps-blue-light));
  border: none;
  border-radius: var(--radius-sm);
  color: white;
  padding: 9px 18px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
  transition: opacity .2s, box-shadow .2s;
  white-space: nowrap;
  box-shadow: 0 4px 12px var(--ps-blue-glow);
}
.suggest-btn:hover { opacity: 0.9; box-shadow: 0 4px 20px rgba(0,112,209,0.5); }

/* FILTER PILLS */
.filter-row {
  display: flex;
  gap: 6px;
  margin-bottom: 10px;
  align-items: center;
  flex-wrap: wrap;
}
.filter-label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text3);
  margin-right: 2px;
}
.pill {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 20px;
  color: var(--text3);
  padding: 4px 12px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.5px;
  cursor: pointer;
  transition: all .15s;
  white-space: nowrap;
}
.pill:hover { border-color: var(--ps-blue); color: var(--ps-blue-light); }
.pill.active {
  background: var(--ps-blue);
  border-color: var(--ps-blue);
  color: white;
  box-shadow: 0 2px 8px var(--ps-blue-glow);
}

/* RESULTS BAR */
.results-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
  padding: 10px 14px;
  background: var(--surface);
  border-radius: var(--radius-sm);
  border: 1px solid var(--border);
}
.results-info { font-family: 'Rajdhani', sans-serif; font-size: 12px; font-weight: 600; letter-spacing: 0.5px; color: var(--text2); }
.results-info strong { color: var(--text); }
.pages-badge {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 3px 8px;
  font-family: 'Orbitron', sans-serif;
  font-size: 9px;
  color: var(--text3);
  letter-spacing: 1px;
}

/* GAME GRID */
.grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 10px; }

/* GAME CARD */
.game-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  transition: border-color .2s, box-shadow .2s, transform .15s;
  position: relative;
}
.game-card:hover {
  border-color: var(--ps-blue);
  box-shadow: 0 4px 20px rgba(0,112,209,0.15);
  transform: translateY(-1px);
}

/* left accent bar */
.card-bar { position: absolute; left: 0; top: 0; bottom: 0; width: 4px; border-radius: 10px 0 0 10px; }
.bar-green { background: linear-gradient(180deg, var(--green), rgba(0,200,150,0.3)); }
.bar-amber { background: linear-gradient(180deg, var(--amber), rgba(240,160,32,0.3)); }
.bar-red { background: linear-gradient(180deg, var(--red), rgba(224,64,80,0.3)); }

.card-inner { padding: 14px 14px 12px 18px; cursor: pointer; }

.card-top { display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; margin-bottom: 10px; }

.game-title {
  font-family: 'Rajdhani', sans-serif;
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.5px;
  flex: 1;
  line-height: 1.3;
  text-transform: capitalize;
}

.pct-badge {
  font-family: 'Orbitron', sans-serif;
  font-size: 13px;
  font-weight: 700;
  padding: 3px 8px;
  border-radius: 6px;
  white-space: nowrap;
  flex-shrink: 0;
}
.pct-high { color: var(--green); background: var(--green-glow); }
.pct-med { color: var(--amber); background: rgba(240,160,32,0.15); }
.pct-low { color: var(--red); background: var(--red-glow); }

/* progress bar */
.prog-bg { background: var(--surface3); height: 4px; border-radius: 2px; margin-bottom: 10px; overflow: hidden; }
.prog-fill { height: 4px; border-radius: 2px; transition: width .4s; }
.prog-green { background: linear-gradient(90deg, var(--green), rgba(0,200,150,0.5)); }
.prog-amber { background: linear-gradient(90deg, var(--amber), rgba(240,160,32,0.5)); }
.prog-red { background: linear-gradient(90deg, var(--red), rgba(224,64,80,0.5)); }

.card-meta { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-bottom: 6px; }

.plat-tag {
  background: var(--surface3);
  border: 1px solid var(--border2);
  border-radius: 4px;
  padding: 2px 7px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.5px;
  color: var(--text2);
}

.trophy-remaining {
  font-family: 'Orbitron', sans-serif;
  font-size: 11px;
  color: var(--text2);
  margin-left: auto;
}
.trophy-remaining span { color: var(--red); font-weight: 700; }

.dead-badge {
  background: rgba(224,64,80,0.15);
  border: 1px solid rgba(224,64,80,0.4);
  border-radius: 4px;
  padding: 2px 6px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 10px;
  font-weight: 700;
  color: var(--red);
  letter-spacing: 0.5px;
}


.game-badges { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
.g-badge {
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  border-radius: 999px;
  padding: 4px 10px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 800;
  letter-spacing: 0.6px;
}
.g-badge.gt-skill { color: var(--red); border-color: rgba(224,64,80,0.35); background: rgba(224,64,80,0.10); }
.g-badge.gt-grind { color: var(--silver); border-color: rgba(160,176,192,0.35); background: rgba(160,176,192,0.10); }
.g-badge.gt-online { color: var(--ps-blue-light); border-color: rgba(26,143,255,0.35); background: rgba(26,143,255,0.10); }
.g-badge.gt-missable { color: var(--amber); border-color: rgba(240,160,32,0.35); background: rgba(240,160,32,0.10); }

.time-row { display: flex; gap: 14px; margin-top: 6px; }
.time-pill {
  display: flex;
  flex-direction: column;
  gap: 1px;
}
.time-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text2); font-family: 'Rajdhani', sans-serif; font-weight: 600; }
.time-val { font-family: 'Orbitron', sans-serif; font-size: 13px; color: var(--ps-blue-light); font-weight: 700; }

.expand-hint {
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  font-weight: 600;
  color: var(--text2);
  margin-top: 8px;
  letter-spacing: 0.5px;
  display: flex;
  align-items: center;
  gap: 4px;
}
.expand-arrow { transition: transform .2s; display: inline-block; }
.game-card.open .expand-arrow { transform: rotate(180deg); }

/* TROPHY DRAWER */
.trophy-drawer {
  display: none;
  border-top: 1px solid var(--border);
  background: rgba(10,10,18,0.8);
}
.trophy-drawer.open { display: block; }

.drawer-header {
  padding: 10px 14px 8px 18px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border);
}
.drawer-title {
  font-family: 'Rajdhani', sans-serif;
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text);
}
.drawer-progress {
  font-family: 'Orbitron', sans-serif;
  font-size: 11px;
  color: var(--text2);
}
.drawer-progress .checked-count { color: var(--green); font-weight: 700; }

.trophy-list { max-height: 280px; overflow-y: auto; padding: 6px 0; }

.trophy-item {
  display: flex;
  gap: 10px;
  padding: 8px 14px 8px 18px;
  border-bottom: 1px solid rgba(42,42,74,0.5);
  align-items: flex-start;
  transition: background .15s;
}
.trophy-item:last-child { border-bottom: none; }
.trophy-item:hover { background: rgba(26,26,46,0.5); }
.trophy-item.is-checked { opacity: 0.5; }

.t-check {
  width: 18px;
  height: 18px;
  border: 1.5px solid var(--border2);
  border-radius: 4px;
  flex-shrink: 0;
  margin-top: 1px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all .15s;
  position: relative;
}
.t-check:hover { border-color: var(--green); background: var(--green-glow); }
.t-check.checked {
  background: var(--green);
  border-color: var(--green);
  box-shadow: 0 0 8px var(--green-glow);
}
.t-check.checked::after { content: 'âœ“'; color: #000; font-size: 11px; font-weight: 700; }

.t-info { flex: 1; }
.t-name { font-family: 'Rajdhani', sans-serif; font-size: 14px; font-weight: 600; margin-bottom: 2px; letter-spacing: 0.3px; }
.t-desc { font-size: 12px; color: var(--text2); line-height: 1.4; }
.t-badges { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
.t-note { display:inline-flex; align-items:center; gap:6px; font-size: 11px; margin-top: 0; padding: 3px 10px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); font-family: 'Rajdhani', sans-serif; font-weight: 700; letter-spacing: 0.5px; }
.note-warn { color: #f0a020; }
.note-skill { color: var(--red); }
.note-online { color: var(--ps-blue-light); }
.note-grind { color: var(--silver); }

/* COMPLETED TAB */
.completed-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 8px; }

.comp-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 14px 14px 12px 18px;
  position: relative;
  overflow: hidden;
  transition: border-color .2s, box-shadow .2s;
}
.comp-card:hover {
  border-color: rgba(184,200,232,0.4);
  box-shadow: 0 4px 16px var(--plat-glow);
}
.comp-card::before {
  content: '';
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 4px;
  border-radius: 10px 0 0 10px;
  background: linear-gradient(180deg, var(--plat), rgba(184,200,232,0.2));
}

.plat-shimmer {
  position: absolute;
  top: 0; right: 0;
  width: 60px; height: 60px;
  background: radial-gradient(circle at top right, rgba(184,200,232,0.08), transparent 70%);
  pointer-events: none;
}

.comp-title {
  font-family: 'Rajdhani', sans-serif;
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 6px;
  text-transform: capitalize;
  letter-spacing: 0.3px;
}

.comp-meta {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.plat-icon-wrap {
  display: flex;
  align-items: center;
  gap: 5px;
}
.plat-diamond {
  width: 14px;
  height: 14px;
  background: linear-gradient(135deg, var(--plat), #7090c0);
  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
  box-shadow: 0 0 6px var(--plat-glow);
}
.comp-trophies {
  font-family: 'Orbitron', sans-serif;
  font-size: 10px;
  color: var(--plat);
  font-weight: 700;
}
.comp-time { font-size: 12px; color: var(--text2); font-family: 'Rajdhani', sans-serif; font-weight: 600; }

/* MODAL */
.modal-bg {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(8px);
  z-index: 200;
  align-items: center;
  justify-content: center;
}
.modal-bg.open { display: flex; }
.modal {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px;
  max-width: 480px;
  width: 90%;
  position: relative;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 0 1px var(--ps-blue-glow);
}
.modal-glow {
  position: absolute;
  top: -1px; left: -1px; right: -1px;
  height: 3px;
  background: linear-gradient(90deg, var(--ps-blue), var(--ps-blue-light), var(--plat));
  border-radius: var(--radius) var(--radius) 0 0;
}
.modal-label { font-family: 'Rajdhani', sans-serif; font-size: 10px; font-weight: 600; letter-spacing: 3px; text-transform: uppercase; color: var(--text3); margin-bottom: 6px; }
.modal-title { font-family: 'Orbitron', sans-serif; font-size: 20px; font-weight: 700; color: var(--text); margin-bottom: 4px; text-transform: capitalize; line-height: 1.2; }
.modal-pct { font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900; color: var(--green); margin-bottom: 8px; }
.modal-pct span { font-size: 13px; color: var(--text3); font-weight: 400; margin-left: 6px; }
.modal-times { display: flex; gap: 16px; margin-bottom: 14px; padding: 12px; background: var(--surface2); border-radius: var(--radius-sm); border: 1px solid var(--border); }
.modal-reason { font-size: 13px; color: var(--text2); line-height: 1.6; margin-bottom: 18px; }
.modal-actions { display: flex; gap: 8px; }
.btn-close {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text2);
  padding: 9px 16px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
}
.btn-next {
  background: linear-gradient(135deg, var(--ps-blue), var(--ps-blue-light));
  border: none;
  border-radius: var(--radius-sm);
  color: white;
  padding: 9px 20px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
  box-shadow: 0 4px 12px var(--ps-blue-glow);
}

.empty { text-align: center; padding: 60px; color: var(--text3); font-family: 'Rajdhani', sans-serif; font-size: 14px; letter-spacing: 1px; grid-column: 1/-1; }

::-webkit-scrollbar { width: 5px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--border2); }

/* GUIDE PANEL */
.guide-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(6px);
  z-index: 300;
  justify-content: flex-end;
}
.guide-overlay.open { display: flex; }

.guide-panel {
  background: var(--surface);
  border-left: 1px solid var(--border);
  width: 420px;
  max-width: 95vw;
  height: 100%;
  display: flex;
  flex-direction: column;
  box-shadow: -20px 0 60px rgba(0,0,0,0.5);
  overflow: hidden;
}

.guide-header {
  padding: 20px 20px 16px;
  border-bottom: 1px solid var(--border);
  position: relative;
}
.guide-header::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3px;
  background: linear-gradient(90deg, var(--ps-blue), var(--ps-blue-light));
}
.guide-game {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text3);
  margin-bottom: 4px;
}
.guide-trophy-name {
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 6px;
  line-height: 1.2;
}
.guide-trophy-desc {
  font-size: 13px;
  color: var(--text2);
  line-height: 1.5;
  margin-bottom: 10px;
}
.guide-tags { display: flex; gap: 6px; flex-wrap: wrap; }
.guide-tag {
  padding: 3px 9px;
  border-radius: 4px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.5px;
}
.gt-difficulty { background: rgba(224,64,80,0.15); color: var(--red); border: 1px solid rgba(224,64,80,0.3); }
.gt-time { background: rgba(0,112,209,0.15); color: var(--ps-blue-light); border: 1px solid rgba(0,112,209,0.3); }
.gt-missable { background: rgba(240,160,32,0.15); color: var(--amber); border: 1px solid rgba(240,160,32,0.3); }
.gt-online { background: rgba(0,200,150,0.15); color: var(--green); border: 1px solid rgba(0,200,150,0.3); }
.gt-grind { background: rgba(160,176,192,0.15); color: var(--silver); border: 1px solid rgba(160,176,192,0.3); }
.gt-skill { background: rgba(224,64,80,0.15); color: var(--red); border: 1px solid rgba(224,64,80,0.3); }

.guide-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px 20px;
}

.guide-section { margin-bottom: 18px; }
.guide-section-title {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--ps-blue-light);
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--border);
}
.guide-steps { display: flex; flex-direction: column; gap: 8px; }
.guide-step {
  display: flex;
  gap: 10px;
  align-items: flex-start;
}
.step-num {
  width: 22px;
  height: 22px;
  background: var(--ps-blue);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Orbitron', sans-serif;
  font-size: 9px;
  font-weight: 700;
  color: white;
  flex-shrink: 0;
  margin-top: 1px;
}
.step-text {
  font-size: 13px;
  color: var(--text2);
  line-height: 1.5;
  flex: 1;
}
.step-text strong { color: var(--text); }

.guide-tip {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-left: 3px solid var(--amber);
  border-radius: 4px;
  padding: 10px 12px;
  font-size: 12px;
  color: var(--text2);
  line-height: 1.5;
  margin-bottom: 8px;
}
.guide-tip strong { color: var(--amber); }

.guide-warning {
  background: rgba(224,64,80,0.08);
  border: 1px solid rgba(224,64,80,0.25);
  border-left: 3px solid var(--red);
  border-radius: 4px;
  padding: 10px 12px;
  font-size: 12px;
  color: var(--text2);
  line-height: 1.5;
  margin-bottom: 8px;
}
.guide-warning strong { color: var(--red); }

.guide-footer {
  padding: 12px 20px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 8px;
  align-items: center;
}
.guide-source {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  color: var(--text3);
}
.guide-source a { color: var(--ps-blue-light); text-decoration: none; }
.guide-source a:hover { text-decoration: underline; }
.guide-close {
  margin-left: auto;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text2);
  padding: 7px 14px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 1px;
  cursor: pointer;
}
.guide-btn {
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--ps-blue-light);
  padding: 2px 8px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all .15s;
  white-space: nowrap;
}
.guide-btn:hover {
  background: var(--ps-blue);
  border-color: var(--ps-blue);
  color: white;
}
</style>
</head>
<body>

<header>
  <div class="logo-wrap">
    <div class="ps-icon">â–²</div>
    <div class="logo">LABYRINTHWORM <span>TROPHIES</span></div>
  </div>
  <div class="header-stats">
    <div class="hstat">
      <span class="hstat-label">Total Games</span>
      <span class="hstat-val blue" id="st-total">â€”</span>
    </div>
    <div class="hstat">
      <span class="hstat-label">Platinums</span>
      <span class="hstat-val plat" id="st-plat">â€”</span>
    </div>
    <div class="hstat">
      <span class="hstat-label">Incomplete</span>
      <span class="hstat-val" id="st-incomplete">â€”</span>
    </div>
    <div class="hstat">
      <span class="hstat-label">Trophies Left</span>
      <span class="hstat-val" id="st-unearned">â€”</span>
    </div>
    <div class="hstat">
      <span class="hstat-label">Checked Off</span>
      <span class="hstat-val green" id="st-checked">0</span>
    </div>
  </div>
</header>

<div class="tabs">
  <div class="tab active" onclick="switchTab('incomplete',this)">
    ðŸŽ¯ Incomplete
    <span class="tab-count" id="tab-inc-count">â€”</span>
  </div>
  <div class="tab" onclick="switchTab('completed',this)">
    â—† Platinums
    <span class="tab-count" id="tab-comp-count">â€”</span>
  </div>
</div>

<div class="container">

  <!-- INCOMPLETE -->
  <div id="tab-incomplete">
    <div class="controls-bar">
      <div class="search-wrap">
        <span class="search-icon">âŒ•</span>
        <input type="text" id="search" placeholder="Search games..." oninput="render()">
      </div>
      <select class="ps-select" id="sort" onchange="render()">
        <option value="pct-desc">% Highest First</option>
        <option value="pct-asc">% Lowest First</option>
        <option value="trophies-asc">Fewest Left</option>
        <option value="alpha">A â†’ Z</option>
        <option value="time-asc">Shortest Plat Time</option>
      </select>
      <select class="ps-select" id="platform" onchange="render()">
        <option value="all">All Platforms</option>
        <option value="PS5">PS5</option>
        <option value="PS4">PS4</option>
        <option value="PS3">PS3</option>
        <option value="Vita">Vita</option>
        <option value="VR">VR</option>
      </select>
      <button class="suggest-btn" onclick="recommend()">âœ¦ Suggest</button>
    </div>

    <div class="filter-row">
      <span class="filter-label">Progress</span>
      <button class="pill active" data-range="all" onclick="setRange(this)">All</button>
      <button class="pill" data-range="near" onclick="setRange(this)">80â€“99%</button>
      <button class="pill" data-range="mid" onclick="setRange(this)">40â€“79%</button>
      <button class="pill" data-range="low" onclick="setRange(this)">Under 40%</button>
      <button class="pill" data-range="quick" onclick="setRange(this)">â‰¤ 5 Left</button>
    </div>

    <div class="filter-row" id="genreFilters">
      <span class="filter-label">Genre</span>
    </div>

    <div class="results-bar">
      <div class="results-info" id="resultsInfo">â€”</div>
      <div class="pages-badge" id="pagesBadge">PAGES 1â€“4 Â· 7 MORE PENDING</div>
    </div>

    <div class="grid" id="grid"></div>
  </div>

  <!-- COMPLETED / PLATINUMS -->
  <div id="tab-completed" style="display:none">
    <div class="controls-bar">
      <div class="search-wrap">
        <span class="search-icon">âŒ•</span>
        <input type="text" id="search-comp" placeholder="Search platinums..." oninput="renderCompleted()">
      </div>
      <select class="ps-select" id="sort-comp" onchange="renderCompleted()">
        <option value="alpha">A â†’ Z</option>
        <option value="trophies-desc">Most Trophies</option>
        <option value="time-desc">Longest Plat Time</option>
      </select>
    </div>
    <div class="results-bar" style="margin-bottom:14px">
      <div class="results-info" id="comp-info">â€”</div>
    </div>
    <div class="completed-grid" id="completed-grid"></div>
  </div>

</div>

<!-- GUIDE PANEL -->
<div class="guide-overlay" id="guideOverlay" onclick="closeGuide(event)">
  <div class="guide-panel" id="guidePanel">
    <div class="guide-header">
      <div class="guide-game" id="guide-game">â€”</div>
      <div class="guide-trophy-name" id="guide-trophy-name">â€”</div>
      <div class="guide-trophy-desc" id="guide-trophy-desc">â€”</div>
      <div class="guide-tags" id="guide-tags"></div>
    </div>
    <div class="guide-body" id="guide-body">
      <div style="color:var(--text3);font-family:'Rajdhani',sans-serif;font-size:13px;padding:20px 0;text-align:center">
        No guide data available yet for this trophy.
      </div>
    </div>
    <div class="guide-footer">
      <div class="guide-source" id="guide-source"></div>
      <button class="guide-close" onclick="closeGuide()">âœ• Close</button>
    </div>
  </div>
</div>

<!-- SUGGEST MODAL -->
<div class="modal-bg" id="modal">
  <div class="modal">
    <div class="modal-glow"></div>
    <div class="modal-label" id="rec-genre">â€”</div>
    <div class="modal-title" id="rec-title">â€”</div>
    <div class="modal-pct" id="rec-pct">â€”<span id="rec-left">â€”</span></div>
    <div class="modal-times" id="rec-times"></div>
    <div class="modal-reason" id="rec-reason">â€”</div>
    <div class="modal-actions">
      <button class="btn-close" onclick="closeModal()">Dismiss</button>
      <button class="btn-next" onclick="recommend()">Next Suggestion â†’</button>
    </div>
  </div>
</div>

<script>
// ========================
// DATA (loaded from ./data/progress.json)
// ========================
let GAME_DATA = {}; // normalized for UI
let RAW_PROGRESS = {}; // raw PocketPSN shape (earned/unearned arrays)
let ENRICHED_DATA = {}; // optional overrides from ./data/enriched.json
// ========================
// STATE
// ========================
let activeRange = 'all';
let activeGenre = 'all';
let recPool = [];
let totalChecked = 0;

// Persisted checklist (localStorage)
const CHECK_KEY = 'trophyTracker.checked.v1';
let checkedState = {};
try { checkedState = JSON.parse(localStorage.getItem(CHECK_KEY) || '{}') || {}; } catch(e) { checkedState = {}; }

function makeCheckId(gameName, trophyName) {
  return (gameName + '||' + trophyName).toLowerCase();
}
function isChecked(gameName, trophyName) {
  return !!checkedState[makeCheckId(gameName, trophyName)];
}
function setChecked(gameName, trophyName, val) {
  checkedState[makeCheckId(gameName, trophyName)] = !!val;
  try { localStorage.setItem(CHECK_KEY, JSON.stringify(checkedState)); } catch(e) {}
}

function syncGameCountsFromChecks() {
  for (const [name, g] of Object.entries(GAME_DATA || {})) {
    syncSingleGameCounts(name, g);
  }
}

function syncSingleGameCounts(gameName, g) {
  if (!g) return;
  const baseU = (typeof g._baseUnearned === 'number') ? g._baseUnearned : (typeof g.unearned === 'number' ? g.unearned : 0);
  const baseE = (typeof g._baseEarned === 'number') ? g._baseEarned : (typeof g.earned === 'number' ? g.earned : 0);

  const trophies = Array.isArray(g.unearnedTrophies) ? g.unearnedTrophies : [];
  let checked = 0;
  for (const t of trophies) {
    if (t && t.name && isChecked(gameName, t.name)) checked++;
  }

  g.earned = baseE + checked;
  g.unearned = Math.max(0, baseU - checked);
  g.completed = (g.unearned === 0);
}



let allEntries = [];
let incompleteEntries = [];
let completedEntries = [];
let totalUnearned = 0;

function recomputeCollectionsAndHeader() {
  allEntries = Object.entries(GAME_DATA);
  incompleteEntries = allEntries.filter(([,g]) => (g.unearned || 0) > 0 && !g.completed);
  completedEntries = allEntries.filter(([,g]) => (g.unearned || 0) === 0 || g.completed);
  totalUnearned = incompleteEntries.reduce((s,[,g]) => s + (g.unearned || 0), 0);

  // Header stats
  document.getElementById('st-total').textContent = allEntries.length;
  document.getElementById('st-plat').textContent = completedEntries.length;
  document.getElementById('st-incomplete').textContent = incompleteEntries.length;
  document.getElementById('st-unearned').textContent = totalUnearned.toLocaleString();
  document.getElementById('tab-inc-count').textContent = incompleteEntries.length;
  document.getElementById('tab-comp-count').textContent = completedEntries.length;

  // checked stat will be computed after render from saved state
}

// ========================
// HELPERS
// ========================
function getPct(g) {
  const total = g.earned + g.unearned;
  return total === 0 ? 100 : Math.round((g.earned / total) * 100);
}
function dispName(name) {
  return name.replace(/\b\w/g, c => c.toUpperCase());
}
function pctTheme(p) {
  if (p >= 80) return { bar: 'bar-green', pct: 'pct-high', prog: 'prog-green' };
  if (p >= 40) return { bar: 'bar-amber', pct: 'pct-med', prog: 'prog-amber' };
  return { bar: 'bar-red', pct: 'pct-low', prog: 'prog-red' };
}

// ========================
// GENRE FILTERS
// ========================
function buildGenrePills() {
  const gf = document.getElementById('genreFilters');
  if (!gf) return;
  // clear existing pills (keep label span as first child)
  // remove all buttons
  gf.querySelectorAll('button.pill').forEach(b => b.remove());

  const allGenres = [...new Set(allEntries.flatMap(([,g]) => (g.genres||[])))].sort();

  function makeGenrePill(label, onclick, active) {
    const b = document.createElement('button');
    b.className = 'pill' + (active ? ' active' : '');
    b.textContent = label;
    b.onclick = onclick;
    return b;
  }

  const allPill = makeGenrePill('All', () => {
    activeGenre = 'all';
    gf.querySelectorAll('button.pill').forEach(b => b.classList.remove('active'));
    allPill.classList.add('active');
    render();
  }, true);
  gf.appendChild(allPill);

  allGenres.forEach(genre => {
    const pill = makeGenrePill(genre, () => {
      activeGenre = genre;
      gf.querySelectorAll('button.pill').forEach(b => b.classList.remove('active'));
      pill.classList.add('active');
      render();
    }, false);
    gf.appendChild(pill);
  });
}

function setRange(btn) {
  activeRange = btn.dataset.range;
  document.querySelectorAll('[data-range]').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  render();
}

// ========================
// TROPHY NOTES AUTO-TAGGING
// ========================
function heuristicTrophyBadges(trophyName, trophyDesc) {
  const text = (trophyName + ' ' + (trophyDesc||'')).toLowerCase();
  const badges = [];

  const push = (key, cls, label) => {
    if (!badges.some(b => b.key === key)) badges.push({ key, cls, label });
  };

  // NOTE: heuristics are conservative. Enrichment overrides can replace these later.
  if (/missable|point of no return|before (you|the)|only chance|single playthrough|no chapter select|cannot return|one[- ]time/i.test(text)) {
    push('MISSABLE', 'note-warn', 'âš  Potentially Missable');
  }
  if (/online|multiplayer|co-?op|ranked|versus|pvp|network|server|lobby|matchmaking/i.test(text)) {
    push('ONLINE', 'note-online', 'ðŸŒ Online Required');
  }
  if (/ultra hard|very hard|nightmare|hardcore|honou?r mode|permadeath|ironman|ironbro|no damage|no death|deathless|flawless|s[- ]?rank|perfect|speedrun/i.test(text)) {
    push('SKILL_WALL', 'note-skill', 'ðŸ’€ Skill Wall');
  }
  if (/collect all|find all|obtain all|complete all|gather all|every (collectible|artifact|relic|card|coin)|100%|grind|farm|level (50|60|70|80|90|99)|1,?000|10,?000/i.test(text)) {
    push('GRIND', 'note-grind', 'â± Grind / Collectibles');
  }

  return badges;
}

const TAG_DISPLAY = {
  'MISSABLE': { cls: 'note-warn', label: 'âš  Potentially Missable' },
  'ONLINE': { cls: 'note-online', label: 'ðŸŒ Online Required' },
  'SKILL_WALL': { cls: 'note-skill', label: 'ðŸ’€ Skill Wall' },
  'GRIND': { cls: 'note-grind', label: 'â± Grind / Collectibles' },
  'BUGGY': { cls: 'note-warn', label: 'ðŸ§¨ Buggy / Tracking Risk' },
  'RNG': { cls: 'note-grind', label: 'ðŸŽ² RNG' },
};

function getTrophyBadges(gameName, trophyName, trophyDesc) {
  const meta = ENRICHED_DATA?.[gameName]?.trophies?.[trophyName];

  // If enrichment provides explicit badges, trust them.
  if (meta && Array.isArray(meta.badges) && meta.badges.length) {
    return meta.badges
      .filter(b => b && (b.label || b.key))
      .map(b => ({
        key: (b.key || b.label || '').toString(),
        cls: b.cls || TAG_DISPLAY[b.key]?.cls || 'note-warn',
        label: b.label || TAG_DISPLAY[b.key]?.label || b.key
      }));
  }

  // If enrichment provides tags, map them.
  if (meta && Array.isArray(meta.tags) && meta.tags.length) {
    return meta.tags
      .map(t => (typeof t === 'string' ? t : ''))
      .filter(Boolean)
      .map(t => ({
        key: t,
        cls: TAG_DISPLAY[t]?.cls || 'note-warn',
        label: TAG_DISPLAY[t]?.label || t
      }));
  }

  // Heuristic fallback
  return heuristicTrophyBadges(trophyName, trophyDesc);
}

function renderBadgeRow(badges) {
  if (!badges || !badges.length) return '';
  return `<div class="t-badges">${badges.map(b => `<div class="t-note ${b.cls}">${b.label}</div>`).join('')}</div>`;
}

function getGameBadges(gameName, g) {
  // Explicit game tags from enrichment (already in UI shape)
  if (Array.isArray(g.gameTags) && g.gameTags.length) return g.gameTags;

  // Otherwise derive from unearned trophies (heuristics + any trophy-level tags)
  const keys = new Set();
  (g.unearnedTrophies || []).forEach(t => {
    const bs = getTrophyBadges(gameName, t.name, t.desc) || [];
    bs.forEach(b => keys.add(b.key));
  });

  const out = [];
  const push = (key, cls, label) => { if (keys.has(key)) out.push({ cls, label }); };
  push('SKILL_WALL', 'gt-skill', 'ðŸ’€ SKILL WALL');
  push('MISSABLE', 'gt-missable', 'âš  MISSABLE');
  push('ONLINE', 'gt-online', 'ðŸŒ ONLINE');
  push('GRIND', 'gt-grind', 'â± GRIND');

  return out;
}


// ========================
// FILTERING & SORTING
// ========================
function getFiltered() {
  const q = document.getElementById('search').value.toLowerCase();
  const sort = document.getElementById('sort').value;
  const plat = document.getElementById('platform').value;

  let games = incompleteEntries.filter(([name, g]) => {
    const p = getPct(g);
    if (q && !name.toLowerCase().includes(q)) return false;
    if (activeGenre !== 'all' && !(g.genres||[]).includes(activeGenre)) return false;
    if (plat !== 'all' && !(g.platforms||[]).includes(plat)) return false;
    if (activeRange === 'near' && p < 80) return false;
    if (activeRange === 'mid' && (p < 40 || p >= 80)) return false;
    if (activeRange === 'low' && p >= 40) return false;
    if (activeRange === 'quick' && g.unearned > 5) return false;
    return true;
  });

  if (sort === 'pct-desc') games.sort(([,a],[,b]) => getPct(b)-getPct(a));
  else if (sort === 'pct-asc') games.sort(([,a],[,b]) => getPct(a)-getPct(b));
  else if (sort === 'trophies-asc') games.sort(([,a],[,b]) => a.unearned-b.unearned);
  else if (sort === 'alpha') games.sort(([a],[b]) => a.localeCompare(b));
  else if (sort === 'time-asc') games.sort(([,a],[,b]) => (parseFloat(a.timePlat)||9999)-(parseFloat(b.timePlat)||9999));
  return games;
}

// ========================
// RENDER INCOMPLETE
// ========================
function toggleDrawer(cardEl, name) {
  const safeName = name.replace(/[^a-z0-9]/g, '');
  const drawer = document.getElementById('dr-' + safeName);
  const isOpen = drawer && drawer.classList.contains('open');
  if (drawer) drawer.classList.toggle('open');
  if (cardEl) cardEl.classList.toggle('open');
}

function updateCheckedStats() {
  const checked = document.querySelectorAll('.t-check.checked').length;
  document.getElementById('st-checked').textContent = checked;
  // Update each drawer progress
  document.querySelectorAll('.trophy-drawer.open').forEach(drawer => {
    const total = drawer.querySelectorAll('.t-check').length;
    const done = drawer.querySelectorAll('.t-check.checked').length;
    const countEl = drawer.querySelector('.checked-count');
    if (countEl) countEl.textContent = done;
  });
}

function render() {
  const games = getFiltered();
  const totalLeft = games.reduce((s,[,g]) => s + g.unearned, 0);
  document.getElementById('resultsInfo').innerHTML =
    `Showing <strong>${games.length}</strong> games Â· <strong>${totalLeft.toLocaleString()}</strong> trophies remaining`;

  const grid = document.getElementById('grid');
  if (!games.length) {
    grid.innerHTML = '<div class="empty">No games match your filters</div>';
    return;
  }

  grid.innerHTML = games.map(([name, g]) => {
    const p = getPct(g);
    const theme = pctTheme(p);
    const safeName = name.replace(/[^a-z0-9]/g, '');

    const platforms = (g.platforms||[]).map(p =>
      `<span class="plat-tag">${p}</span>`).join('');

    const gameBadges = getGameBadges(name, g);
    const gameBadgesHtml = gameBadges && gameBadges.length ? `<div class="game-badges">${gameBadges.map(b=>`<span class="g-badge ${b.cls}">${b.label}</span>`).join('')}</div>` : '';

    const dead = g.platDead
      ? `<span class="dead-badge">ðŸš« PLAT DEAD${g.deadReason ? ' Â· ' + g.deadReason : ''}</span>` : '';

    const times = (g.timeNormal || g.timeHastily || g.timePlat) ? `
      <div class="time-row">
        ${g.timeNormal ? `<div class="time-pill"><span class="time-label">Normal</span><span class="time-val">${g.timeNormal}</span></div>` : ''}
        ${g.timeHastily ? `<div class="time-pill"><span class="time-label">Hastily</span><span class="time-val">${g.timeHastily}</span></div>` : ''}
        ${g.timePlat ? `<div class="time-pill"><span class="time-label">Platinum</span><span class="time-val">${g.timePlat}</span></div>` : ''}
      </div>` : '';

    const hasDrawer = g.unearnedTrophies && g.unearnedTrophies.length > 0;

    const trophyItems = hasDrawer ? g.unearnedTrophies.map((t, idx) => {
      const badges = getTrophyBadges(name, t.name, t.desc);
      const badgesHtml = renderBadgeRow(badges);
      const hasGuide = TROPHY_GUIDES[name]?.[t.name];
      const guideBtn = `<button class="guide-btn" onclick="event.stopPropagation();openGuide('${name.replace(/'/g,"\\'")}','${t.name.replace(/'/g,"\\'")}','${(t.desc||'').replace(/'/g,"\\'")}')">ðŸ“– Guide</button>`;
      return `
        <div class="trophy-item" id="ti-${safeName}-${idx}">
          <div class="t-check ${isChecked(name, t.name) ? 'checked' : ''}" data-game="${name.replace(/&/g,'&amp;').replace(/"/g,'&quot;')}" data-trophy="${t.name.replace(/&/g,'&amp;').replace(/"/g,'&quot;')}" title="Mark as done/planned"></div>
          <div class="t-info">
            <div class="t-name" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">${t.name} ${hasGuide ? guideBtn : `<button class="guide-btn" style="opacity:0.4" onclick="event.stopPropagation();openGuide('${name.replace(/'/g,"\\'")}','${t.name.replace(/'/g,"\\'")}','${(t.desc||'').replace(/'/g,"\\'")}')">ðŸ“– Guide</button>` }</div>
            ${t.desc ? `<div class="t-desc">${t.desc}</div>` : ''}
            ${badgesHtml}
          </div>
        </div>`;
    }).join('') : '';

    const drawer = hasDrawer ? `
      <div class="trophy-drawer" id="dr-${safeName}" data-game="${name.replace(/&/g,'&amp;').replace(/"/g,'&quot;')}">
        <div class="drawer-header">
          <span class="drawer-title">Remaining Trophies</span>
          <span class="drawer-progress"><span class="checked-count">0</span> / ${g.unearnedTrophies.length} checked</span>
        </div>
        <div class="trophy-list">${trophyItems}</div>
      </div>` : '';

    return `
      <div class="game-card" id="card-${safeName}">
        <div class="card-bar ${theme.bar}"></div>
        <div class="card-inner" onclick="toggleDrawer(document.getElementById('card-${safeName}'),'${name}')">
          <div class="card-top">
            <div class="game-title">${dispName(name)}</div>
            <div class="pct-badge ${theme.pct}">${p}%</div>
          </div>
          <div class="prog-bg"><div class="prog-fill ${theme.prog}" style="width:${p}%"></div></div>
          <div class="card-meta">
            ${platforms}
            ${dead}
            <span class="trophy-remaining" style="margin-left:auto"><span>${g.unearned}</span> left</span>
          </div>
          ${times}
          ${gameBadgesHtml}
          ${hasDrawer ? `<div class="expand-hint"><span class="expand-arrow">â–¾</span> ${g.unearned} trophies Â· tap to expand</div>` : ''}
        </div>
        ${drawer}
      </div>`;
  }).join('');
}

function handleCheck(evt, el) {
  if (evt) evt.stopPropagation();

  el.classList.toggle('checked');
  const row = el.closest('.trophy-item');
  if (row) row.classList.toggle('is-checked', el.classList.contains('checked'));

  const gameName = el.getAttribute('data-game') || '';
  const trophyName = el.getAttribute('data-trophy') || '';
  if (gameName && trophyName) {
    setChecked(gameName, trophyName, el.classList.contains('checked'));
    // Update the game counts so % / remaining / completed state react immediately
    syncSingleGameCounts(gameName, GAME_DATA[gameName]);
  }

  // Recompute lists + rerender current tab so games can move between In Progress / Completed
  const openDrawer = document.querySelector('.trophy-drawer.open')?.getAttribute('data-game') || null;
  const activeTab = document.querySelector('.tab.active')?.getAttribute('data-tab') || 'incomplete';

  recomputeCollectionsAndHeader();
  if (activeTab === 'completed') renderCompleted();
  else render();

  recommend();
  updateCheckedStats();

  // Re-open drawer if it was open
  if (openDrawer) {
    const safe = openDrawer.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
    const dr = document.getElementById('dr-' + safe);
    if (dr) dr.classList.add('open');
  }
}

// ========================
// RENDER COMPLETED
// ========================
function renderCompleted() {
  const q = document.getElementById('search-comp').value.toLowerCase();
  const sort = document.getElementById('sort-comp').value;
  let games = completedEntries.filter(([name]) => !q || name.includes(q));

  if (sort === 'alpha') games.sort(([a],[b]) => a.localeCompare(b));
  else if (sort === 'trophies-desc') games.sort(([,a],[,b]) => b.earned - a.earned);
  else if (sort === 'time-desc') games.sort(([,a],[,b]) => (parseFloat(b.timePlat)||0) - (parseFloat(a.timePlat)||0));

  document.getElementById('comp-info').innerHTML =
    `<strong>${games.length}</strong> platinum trophies earned`;

  const grid = document.getElementById('completed-grid');
  if (!games.length) { grid.innerHTML = '<div class="empty">No games found</div>'; return; }

  grid.innerHTML = games.map(([name, g]) => `
    <div class="comp-card">
      <div class="plat-shimmer"></div>
      <div class="comp-title">${dispName(name)}</div>
      <div class="comp-meta">
        <div class="plat-icon-wrap">
          <div class="plat-diamond"></div>
          <span class="comp-trophies">${g.earned}</span>
        </div>
        ${g.timePlat ? `<span class="comp-time">Â· ${g.timePlat} platinum</span>` : ''}
        ${(g.platforms||[]).map(p => `<span class="plat-tag">${p}</span>`).join('')}
      </div>
    </div>`).join('');
}

// ========================
// SUGGEST
// ========================
function parseHours(str) {
  if (!str) return null;
  const s = String(str).toLowerCase();
  // Extract numbers like "25-40h", "127 hours", "15h", "10â€“20"
  const nums = (s.match(/\d+(?:\.\d+)?/g) || []).map(n => parseFloat(n)).filter(n => !isNaN(n));
  if (!nums.length) return null;
  let minH = nums[0], maxH = nums[0];
  if (nums.length >= 2) {
    minH = Math.min(nums[0], nums[1]);
    maxH = Math.max(nums[0], nums[1]);
  }
  const avgH = (minH + maxH) / 2;
  return { min: minH, max: maxH, avg: avgH };
}

function getRemainingHoursEstimate(g) {
  const p = getPct(g) / 100;
  const t = parseHours(g.timePlat || g.timeNormal || g.timeHastily);
  if (t) {
    // Assume time fields are "to complete" (plat/100%). Remaining is proportional to completion.
    const rem = Math.max(0.25, t.avg * (1 - p));
    return { known: true, hours: rem, totalAvg: t.avg };
  }
  // Fallback when no time data exists: estimate using trophy count + risk weight.
  const trophyCount = (g.unearnedTrophies || []).length || (g.unearned || 0);
  const risk = getRiskSummary(g)._riskPoints;
  const base = trophyCount * 0.75;     // ~45 min per remaining trophy baseline
  const riskAdd = risk * 0.6;          // harder trophies add time uncertainty
  const rem = Math.max(0.5, base + riskAdd);
  return { known: false, hours: rem, totalAvg: null };
}

function getRiskSummary(g) {
  // Aggregate risk based on remaining trophies.
  const trophies = (g.unearnedTrophies || []);
  let skill = 0, miss = 0, online = 0, grind = 0, buggy = 0, rng = 0;
  let points = 0;

  trophies.forEach(t => {
    const bs = (getTrophyBadges(g._name || '', t.name, t.desc) || []);
    const keys = new Set(bs.map(b => b.key));
    if (keys.has('SKILL_WALL')) { skill++; points += 6; }
    if (keys.has('ONLINE')) { online++; points += 5; }
    if (keys.has('MISSABLE')) { miss++; points += 3; }
    if (keys.has('GRIND')) { grind++; points += 2; }
    if (keys.has('BUGGY')) { buggy++; points += 5; }
    if (keys.has('RNG')) { rng++; points += 3; }
  });

  return {
    skill, miss, online, grind, buggy, rng,
    _riskPoints: points
  };
}

function scoreGameForRecommendation(name, g) {
  // Higher score = better "finish candidate"
  const pct = getPct(g);
  const left = g.unearned || 0;

  // Risk & remaining-time estimation
  g._name = name; // for badge lookup (enrichment may be keyed by name)
  const risk = getRiskSummary(g);
  const timeEst = getRemainingHoursEstimate(g);

  // Normalize: reward high completion, penalize risk, penalize time, small penalty for trophies left
  const timePenalty = timeEst.hours * 8; // each hour costs points
  const riskPenalty = risk._riskPoints * 7; // each risk point costs points
  const leftPenalty = left * 1.2;

  // Bonus for being close to done (finisher bias), but not so much that a single nightmare trophy dominates.
  const finishBonus = pct >= 90 ? 120 : pct >= 80 ? 80 : pct >= 60 ? 40 : 0;

  // If game is marked dead platinum, exclude it elsewhere.
  const score = (pct * 3.0) + finishBonus - timePenalty - riskPenalty - leftPenalty;

  return { score, pct, left, risk, timeEst };
}

function buildRecReason(name, g, s) {
  const { pct, left, risk, timeEst } = s;

  const riskBits = [];
  if (risk.skill) riskBits.push(`${risk.skill} skill-wall`);
  if (risk.online) riskBits.push(`${risk.online} online`);
  if (risk.miss) riskBits.push(`${risk.miss} missable`);
  if (risk.grind) riskBits.push(`${risk.grind} grind`);
  const riskText = riskBits.length ? `Risk profile: ${riskBits.join(', ')}.` : `No major risk flags detected.`;

  const timeText = timeEst.known
    ? `Estimated remaining time: ~${Math.round(timeEst.hours)}h (based on ${g.timePlat || g.timeNormal || g.timeHastily}).`
    : `Estimated remaining time: ~${Math.round(timeEst.hours)}h (heuristic â€” no time data yet).`;

  // Primary reason focuses on: close-to-finish + low remaining time
  if (pct >= 80 && timeEst.hours <= 12 && risk.skill === 0) {
    return `High completion (${pct}%) with a small remaining estimate. ${timeText} ${riskText}`;
  }
  if (pct >= 80 && timeEst.hours <= 20) {
    return `You're ${pct}% in â€” this is a strong finisher candidate. ${timeText} ${riskText}`;
  }
  if (timeEst.hours <= 10) {
    return `Low estimated remaining time makes this a quick win. ${timeText} ${riskText}`;
  }
  if (risk.skill || risk.online || risk.miss) {
    return `This is doable, but the remaining trophies include higher-risk items. ${timeText} ${riskText}`;
  }
  return `A reasonable candidate based on progress and remaining effort. ${timeText} ${riskText}`;
}

function recommend() {
  const games = getFiltered().filter(([,g]) => !g.platDead);
  if (!games.length) return;

  // Build pool with scores once per filter state.
  if (!recPool.length) {
    recPool = games
      .map(([name, g]) => {
        const s = scoreGameForRecommendation(name, g);
        return { name, g, s };
      })
      // Sort best-first, but keep mild randomness to avoid picking the same game forever.
      .sort((a, b) => (b.s.score - a.s.score) + (Math.random() - 0.5) * 8);
  }

  const next = recPool.shift() || { name: games[0][0], g: games[0][1], s: scoreGameForRecommendation(games[0][0], games[0][1]) };
  const { name, g, s } = next;

  const p = getPct(g);
  document.getElementById('rec-title').textContent = dispName(name);
  document.getElementById('rec-pct').innerHTML = `${p}%<span> Â· ${g.unearned} trophies left</span>`;
  document.getElementById('rec-genre').textContent = (g.genres||[]).join(' Â· ') || 'Uncategorized';
  document.getElementById('rec-reason').textContent = buildRecReason(name, g, s);

  const te = document.getElementById('rec-times');
  const timeStr = (g.timeNormal || g.timePlat || g.timeHastily);
  const rem = s.timeEst?.hours;
  te.innerHTML = timeStr ? `
    ${g.timeNormal ? `<div class="time-pill"><span class="time-label">Normal</span><span class="time-val">${g.timeNormal}</span></div>` : ''}
    ${g.timeHastily ? `<div class="time-pill"><span class="time-label">Hastily</span><span class="time-val">${g.timeHastily}</span></div>` : ''}
    ${g.timePlat ? `<div class="time-pill"><span class="time-label">Platinum</span><span class="time-val">${g.timePlat}</span></div>` : ''}
    ${rem ? `<div class="time-pill"><span class="time-label">Est. Remaining</span><span class="time-val">~${Math.round(rem)}h</span></div>` : ''}
  ` : `
    <div class="time-pill"><span class="time-label">Est. Remaining</span><span class="time-val">~${Math.round(rem||0)}h</span></div>
  `;

  document.getElementById('modal').classList.add('open');
}

function closeModal() { document.getElementById('modal').classList.remove('open'); }
document.getElementById('modal').addEventListener('click', e => {
  if (e.target === document.getElementById('modal')) closeModal();
});

function switchTab(tab, btn) {
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  btn.classList.add('active');
  document.getElementById('tab-incomplete').style.display = tab === 'incomplete' ? '' : 'none';
  document.getElementById('tab-completed').style.display = tab === 'completed' ? '' : 'none';
  if (tab === 'completed') renderCompleted();
}

// ========================
// TROPHY GUIDE DATABASE
// ========================
const TROPHY_GUIDES = {
  "horizon forbidden west": {
    "Completed New Game+": {
      tags: [{ cls: 'gt-difficulty', label: 'ðŸ’€ Requires NG+' }, { cls: 'gt-time', label: '~20-30H' }],
      sections: [
        {
          title: 'How to Unlock',
          steps: [
            'Complete the main story on any difficulty first to unlock New Game+ mode.',
            'Head to The Base and interact with the device in the common room to start NG+.',
            'Choose <strong>any difficulty</strong> â€” Story mode is fine if you just want this trophy.',
            'Complete all 17 story missions. You can rush straight through without doing side content.',
            'Trophy pops upon completing the final story mission in NG+.'
          ]
        }
      ],
      tips: [
        { type: 'tip', text: '<strong>Tip:</strong> If you plan to do Ultra Hard anyway, you can combine this with "Completed Ultra Hard" and knock out both in one run.' },
        { type: 'tip', text: '<strong>Tip:</strong> Story difficulty makes enemies die in a few hits. Fastest route to just pop this trophy.' }
      ],
      source: { label: 'PSNProfiles Guide', url: 'https://psnprofiles.com/guide/14625-horizon-forbidden-west-new-game-dlc-trophy-guide' }
    },
    "Completed Ultra Hard": {
      tags: [{ cls: 'gt-skill', label: 'ðŸ’€ Skill Wall' }, { cls: 'gt-difficulty', label: 'Ultra Hard' }, { cls: 'gt-time', label: '~25-40H' }],
      sections: [
        {
          title: 'How to Unlock',
          steps: [
            'Complete the main story once on any difficulty to unlock NG+ and Ultra Hard mode.',
            'Start a New Game+ and select <strong>Ultra Hard</strong> difficulty.',
            'On Ultra Hard: enemies have more health, deal more damage, health bars are hidden, and AI is more aggressive.',
            'Complete all 17 story missions on Ultra Hard. Side content is optional for this trophy.',
            'Trophy pops on completing the final mission.'
          ]
        },
        {
          title: 'Ultra Hard Tips',
          steps: [
            '<strong>Upgrade your gear</strong> before starting â€” bring your best coils and weaves from your first playthrough.',
            'Use the Sunwing to skip dangerous overworld encounters and save time.',
            'Elemental damage (shock, fire, frost) is very effective for staggering tough enemies.',
            'Stealth kills and traps are your best friends â€” avoid open fights where possible.',
            'If you get stuck, you can do Ultra Hard on a <em>second</em> NG+ cycle with better gear.'
          ]
        }
      ],
      tips: [
        { type: 'warning', text: '<strong>Warning:</strong> Once you select Ultra Hard, you CANNOT lower the difficulty mid-playthrough. If you want to switch, you must start another NG+ cycle.' },
        { type: 'tip', text: '<strong>Tip:</strong> You can earn Champion Tokens simultaneously during this run â€” get both Ultra Hard and All NG+ Rewards done in one playthrough if possible.' }
      ],
      source: { label: 'PSNProfiles Guide', url: 'https://psnprofiles.com/guide/14625-horizon-forbidden-west-new-game-dlc-trophy-guide' }
    },
    "Obtained All New Game+ Rewards": {
      tags: [{ cls: 'gt-grind', label: 'â± Heavy Grind' }, { cls: 'gt-time', label: '40-60H total' }],
      sections: [
        {
          title: 'What You Need',
          steps: [
            'Collect <strong>125 Champion Tokens</strong> total across any number of NG+ playthroughs.',
            'Spend all tokens buying every NG+ weapon, dye, and face paint from vendors.',
            'Tokens carry over between NG+ cycles â€” no need to do it all in one run.',
            'Story completion gives 30 tokens (2 per main mission, tutorials excluded).',
            'Side missions, Tallnecks, Relic Ruins, Cauldrons, Rebel Camps = 2 tokens each. Errands = 1 token each.'
          ]
        },
        {
          title: 'Fastest Strategy',
          steps: [
            '<strong>Run 1 (Ultra Hard):</strong> Complete main story + Tallnecks + Rebel Camps + Relic Ruins. Target ~75 tokens.',
            '<strong>Run 2 (Story difficulty):</strong> Start another NG+, rush story + remaining side content for the last ~50 tokens.',
            'Alternatively: do everything in one run on any difficulty if you have enough patience.',
            'Use the <strong>Sunwing</strong> to fly directly to objectives â€” skip all the climbing.',
            'Buy face paints and dyes first â€” those vendors disappear later in the game.'
          ]
        }
      ],
      tips: [
        { type: 'warning', text: '<strong>Warning:</strong> Buy face paints and dyes EARLY â€” their vendors become unavailable at certain story points. Prioritize these before weapons.' },
        { type: 'tip', text: '<strong>Tip:</strong> If you own the Burning Shores DLC, its 5 story missions grant 33 bonus tokens â€” a significant shortcut.' },
        { type: 'tip', text: '<strong>Tip:</strong> Token purchases carry over between NG+ cycles, so you can spread this across multiple shorter playthroughs at any difficulty.' }
      ],
      source: { label: 'PSNProfiles Guide', url: 'https://psnprofiles.com/guide/14625-horizon-forbidden-west-new-game-dlc-trophy-guide' }
    }
  },
  "shinobi art of vengeance": {
    "SEGA Mega Play": {
      tags: [
        { cls: 'gt-difficulty', label: 'ðŸ’€ Hardest Trophy' },
        { cls: 'gt-skill', label: 'âš”ï¸ Skill Wall' },
        { cls: 'gt-time', label: '~5-15H' }
      ],
      sections: [
        {
          title: 'Overview',
          steps: [
            'Arcade Mode unlocks after beating the story. You must earn S rank on <strong>all Arcade stages</strong> â€” with the exception of "The Chase", "Riptide", and "Ruse\'s Castle" which cannot be played in Arcade.',
            'S rank requires a minimum score of <strong>65,000 points</strong> per stage.',
            'Score is built from a base score + bonuses: <strong>Time</strong> is the biggest factor, followed by <strong>No Damage Taken</strong> and <strong>Highest Combo</strong>. Other bonuses include No Ninjutsu Used (+10,000) and No Assists Used (+10,000, meaning no accessibility options and playing on default "Shinobi" difficulty).',
            'Two viable paths to S rank: (1) <strong>No Damage + Speed</strong>, or (2) <strong>Combo Exploit</strong> to bank massive points early and cruise the rest.'
          ]
        },
        {
          title: 'Best Loadout: Berserker + Shield Amulets',
          steps: [
            'Equip the <strong>Berserker Amulet</strong> â€” it ramps up damage the higher your combo count, to the point of one- or two-shotting bosses with Fire Ninpo at high counts.',
            'Pair it with the <strong>Shield Amulet</strong> â€” absorbs one hit every 60 seconds without resetting your combo. Effectively gives you a free mistake per minute.',
            'If you lose the shield, wait for it to regenerate before engaging again.',
            'A good third option is <strong>Kunai Finder</strong> â€” essentially gives you infinite Kunai when combo is above 20, which fuels Thunder Ninpo farming.',
            '<strong>Thunder Ninpo</strong> is especially useful for the combo exploit (see below).'
          ]
        },
        {
          title: 'The Combo Score Exploit (Easiest Method)',
          steps: [
            'Most stages contain <strong>healers or healing devices</strong> that regenerate infinitely. Find these spots and wail on them to inflate your combo to 600â€“999+ hits.',
            'With <strong>Thunder Ninpo</strong>, you can chain hits rapidly on these targets to build the counter faster.',
            'Armored enemies also work â€” their armor <strong>regenerates after a few seconds</strong> if left alone, so you can keep hitting them indefinitely.',
            'Once you\'ve banked a massive combo score from this exploit, you can finish the rest of the stage at a reasonable pace without needing No Damage or fast time to hit S rank.',
            'The guide from PSNProfiles notes each stage\'s specific farming opportunity â€” look up which healer/armored enemy is available in the stage you\'re struggling with.'
          ]
        },
        {
          title: 'Key Tips for No-Damage / Speed Runs',
          steps: [
            'Prioritize breaking enemy <strong>armor first</strong> â€” armored enemies won\'t stagger and resist burst damage. Use Shuriken Ninpo (ground) or Bomb Ninpo (air) to strip armor.',
            'The divekick combo is the most powerful sustained DPS: <strong>Divekick â†’ Buzzsaw (don\'t spin to ground) â†’ Kunai â†’ cancel into Bomb Ninpo â†’ cancel into Air Slash Ninpo</strong>. If you still have your double jump, you can repeat the full sequence.',
            'Don\'t waste time on Medals or extra enemies unless you calculate they\'re needed to push you over 65,000. Speed is worth more than extra kills.',
            'Use <strong>Shinobi Executions</strong> (fill the execution gauge on individual enemies) for big gold and potentially free Kunai/Rage refills.',
            '<strong>Do NOT use Ninjutsu</strong> (the Rage-bar abilities) if you want the +10,000 bonus. Ninpo (the charged magic attacks) is fine â€” they\'re separate.'
          ]
        },
        {
          title: 'Stage-Specific Notes',
          steps: [
            '<strong>Oboro Village (Stage 1)</strong> is the easiest starting point â€” short, simple enemies. Great for the "complete untouched" trophy simultaneously, and relatively easy S rank.',
            'Boss fights are dramatically easier with a high Berserker combo stacked â€” at 999 hits, Fire Ninpo can vaporize most bosses in 1-2 hits.',
            'Stages with mid-stage healers are the easiest to exploit â€” get to the healer fast, farm to 999, then sprint to the exit.'
          ]
        }
      ],
      tips: [
        { type: 'warning', text: '<strong>Warning:</strong> Do NOT have accessibility options turned on â€” they disable the +10,000 "No Assists" bonus, making S rank harder to reach. The game does NOT disable trophies for using them, but the score penalty is real.' },
        { type: 'tip', text: '<strong>Tip:</strong> The combo exploit essentially makes time the only real constraint. As long as you hit the healer early and farm 600-999 hits, you can take damage and still hit S rank without needing to play perfectly.' },
        { type: 'tip', text: '<strong>Tip:</strong> Berserker + Shield is considered the strongest combo in the entire game â€” this setup will make every stage significantly more manageable.' },
        { type: 'warning', text: '<strong>Note:</strong> "The Chase", "Riptide", and "Ruse\'s Castle" are excluded from Arcade Mode entirely â€” you only need S ranks on the remaining stages.' }
      ],
      source: { label: 'PSNProfiles Guide', url: 'https://psnprofiles.com/guide/23945-shinobi-art-of-vengeance-trophy-guide' }
    }
  }
};

function openGuide(gameName, trophyName, trophyDesc) {
  const guide = TROPHY_GUIDES[gameName]?.[trophyName];

  document.getElementById('guide-game').textContent = gameName.replace(/\b\w/g, c => c.toUpperCase());
  document.getElementById('guide-trophy-name').textContent = trophyName;
  document.getElementById('guide-trophy-desc').textContent = trophyDesc || '';

  // Tags
  const tagsEl = document.getElementById('guide-tags');
  if (guide?.tags) {
    tagsEl.innerHTML = guide.tags.map(t => `<span class="guide-tag ${t.cls}">${t.label}</span>`).join('');
  } else {
    tagsEl.innerHTML = '';
  }

  // Body
  const body = document.getElementById('guide-body');
  if (!guide) {
    body.innerHTML = `<div style="color:var(--text3);font-family:'Rajdhani',sans-serif;font-size:13px;padding:20px 0;text-align:center;line-height:1.8">
      No guide researched yet for this trophy.<br>
      <span style="font-size:11px">More guides coming as pages are uploaded.</span>
    </div>`;
    document.getElementById('guide-source').innerHTML = '';
  } else {
    let html = '';
    // Sections
    for (const section of guide.sections || []) {
      html += `<div class="guide-section">
        <div class="guide-section-title">${section.title}</div>
        <div class="guide-steps">
          ${section.steps.map((s, i) => `
            <div class="guide-step">
              <div class="step-num">${i+1}</div>
              <div class="step-text">${s}</div>
            </div>`).join('')}
        </div>
      </div>`;
    }
    // Tips/warnings
    if (guide.tips?.length) {
      html += `<div class="guide-section"><div class="guide-section-title">Tips & Warnings</div>`;
      for (const tip of guide.tips) {
        html += tip.type === 'warning'
          ? `<div class="guide-warning">${tip.text}</div>`
          : `<div class="guide-tip">${tip.text}</div>`;
      }
      html += '</div>';
    }
    body.innerHTML = html;

    // Source
    if (guide.source) {
      document.getElementById('guide-source').innerHTML =
        `Source: <a href="${guide.source.url}" target="_blank">${guide.source.label}</a>`;
    }
  }

  document.getElementById('guideOverlay').classList.add('open');
}

function closeGuide(e) {
  if (!e || e.target === document.getElementById('guideOverlay')) {
    document.getElementById('guideOverlay').classList.remove('open');
  }
}


async function normalizeAndLoad() {
  // Load PocketPSN progress (raw)
  const resp = await fetch('./data/progress.json');
  if (!resp.ok) throw new Error('Failed to load ./data/progress.json (' + resp.status + ')');
  RAW_PROGRESS = await resp.json();

  // Normalize to the UI model expected by this app
  GAME_DATA = {};
  for (const [name, g] of Object.entries(RAW_PROGRESS)) {
    const earnedArr = Array.isArray(g.earned) ? g.earned : [];
    const unearnedArr = Array.isArray(g.unearned) ? g.unearned : [];

    const earnedCount = typeof g.earned === 'number' ? g.earned : earnedArr.length;
    const unearnedCount = typeof g.unearned === 'number' ? g.unearned : unearnedArr.length;

    GAME_DATA[name] = {
      _baseEarned: earnedCount,
      _baseUnearned: unearnedCount,
      earned: earnedCount,
      unearned: unearnedCount,
      timePlat: g.timePlat ?? null,
      timeNormal: g.timeNormal ?? null,
      timeHastily: g.timeHastily ?? null,
      platforms: Array.isArray(g.platforms) ? g.platforms : [],
      genres: Array.isArray(g.genres) ? g.genres : [],
      completed: (unearnedCount === 0),
      // optional list used by the trophy drawer
      unearnedTrophies: (Array.isArray(g.unearnedTrophies) ? g.unearnedTrophies : unearnedArr).map(t => ({
        name: t.name ?? '',
        desc: t.desc ?? ''
      }))
    };
  }

  // Optional: merge in external guides file (keeps inline guides as fallback)
  try {
    const gr = await fetch('./data/guides.json');
    if (gr.ok) {
      const extra = await gr.json();
      // shallow merge: game -> trophy -> guide
      for (const [game, trophies] of Object.entries(extra || {})) {
        TROPHY_GUIDES[game] = TROPHY_GUIDES[game] || {};
        for (const [tName, guide] of Object.entries(trophies || {})) {
          TROPHY_GUIDES[game][tName] = guide;
        }
      }
    }

  // Optional: merge in enrichment overrides (badges, dead plats, time estimates, missables, etc.)
  try {
    const er = await fetch('./data/enriched.json');
    if (er.ok) {
      ENRICHED_DATA = await er.json();
      for (const [game, meta] of Object.entries(ENRICHED_DATA || {})) {
        if (!GAME_DATA[game] || !meta) continue;
        // Game-level overrides
        if (typeof meta.platDead === 'boolean') GAME_DATA[game].platDead = meta.platDead;
        if (typeof meta.deadReason === 'string') GAME_DATA[game].deadReason = meta.deadReason;
        if (meta.timePlat != null) GAME_DATA[game].timePlat = meta.timePlat;
        if (meta.timeNormal != null) GAME_DATA[game].timeNormal = meta.timeNormal;
        if (meta.timeHastily != null) GAME_DATA[game].timeHastily = meta.timeHastily;
        if (meta.estimatedHours && (meta.estimatedHours.min || meta.estimatedHours.max)) {
          GAME_DATA[game].estimatedHours = meta.estimatedHours;
        }
        if (Array.isArray(meta.gameTags)) {
          GAME_DATA[game].gameTags = meta.gameTags;
        }
      }
    }
  } catch (e) {}

  } catch (e) {}
}

async function initApp() {
  try {
    await normalizeAndLoad();
    syncGameCountsFromChecks();
    recomputeCollectionsAndHeader();
    buildGenrePills();
// checkbox delegation (trophy checklist)
    document.addEventListener('click', (e) => {
      const box = e.target.closest('.t-check');
      if (box) handleCheck(e, box);
    });

    render();
    renderCompleted();
    // apply checked stats based on persisted state
    updateCheckedStats();
  } catch (e) {
    console.error(e);
    const grid = document.getElementById('grid');
    if (grid) {
      grid.innerHTML = '<div class="empty">Failed to load data. Open DevTools Console for details.<br><br><span style="color:var(--text3)">Expected: ./data/progress.json</span></div>';
    }
  }
}

initApp();


</script>
</body>
</html>